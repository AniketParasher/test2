# -*- coding: utf-8 -*-
"""Python Automation Task V3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WAvR2oOhcpJW5Mcb67I24zdaMdQVH1Sa
"""

import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import Font
from openpyxl.styles.borders import Border, Side
from openpyxl.styles import Border, Side, Alignment
from openpyxl.worksheet.page import PageMargins
from openpyxl.worksheet.dimensions import ColumnDimension, DimensionHolder
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.page import PageMargins

df = pd.read_excel('/content/All Data.xlsx')

# Identify columns excluding 'Student ID' and those that are entirely empty
grouping_columns = [col for col in df.columns if col not in ['STUDENT ID'] and df[col].notna().any()]

# Group by the identified columns and count the number of unique 'Student ID'
grouped = df.groupby(grouping_columns).agg(student_count=('STUDENT ID', 'nunique')).reset_index()

# Process 'CLASS' column if it exists and contains non-numeric values
if 'CLASS' in grouped.columns and grouped['CLASS'].astype(str).str.contains('\D').any():
    grouped['CLASS'] = grouped['CLASS'].astype(str).str.extract('(\d+)')

# Count distinct schools
num_distinct_schools = grouped['School Code'].nunique()
print("Number of distinct schools:", num_distinct_schools)

# Convert the result to a list of dictionaries
result = grouped.to_dict(orient='records')

# Iterate over the list of dictionaries
for school in result:
    wb = load_workbook('/content/Template modified V3.xlsx')
    ws = wb.active

    # Update "ATTENDANCE LIST" formatting
    for row in ws.iter_rows():
        for cell in row:
            if cell.value and "ATTENDANCE LIST" in str(cell.value):
                cell.font = Font(name='Calibri', size=20, bold=True)
                break

    # Update "(PLEASE FILL ALL THE DETAILS IN BLOCK LETTERS)" formatting
    for row in ws.iter_rows():
        for cell in row:
            if cell.value and "(PLEASE FILL ALL THE DETAILS IN BLOCK LETTERS)" in str(cell.value):
                cell.font = Font(name='Calibri', size=9)
                break

    # Update the PROJECT, DISTRICT, BLOCK, SCHOOL, and CLASS fields
    for row in ws.iter_rows():
        for cell in row:
            if cell.value:
                cell_value = str(cell.value)
                if "PROJECT :" in cell_value:
                    # Check if 'PROJECT-CITY' key exists before accessing it
                    project_city = school.get('PROJECT-CITY', '') # Use 'Unknown' or an appropriate default if the key is missing
                    cell.value = f"PROJECT : {project_city}"
                elif "DISTRICT :" in cell_value:
                    district = school.get('District', '') # Use 'Unknown' or an appropriate default if the key is missing
                    cell.value = f"DISTRICT : {district}"
                elif "BLOCK :" in cell_value:
                    block = school.get('Block', '') # Use 'Unknown' or an appropriate default if the key is missing
                    cell.value = f"BLOCK : {block}"
                elif "SCHOOL :" in cell_value:
                    school_name = school.get('SCHOOL NAME', '') # Use 'Unknown' or an appropriate default if the key is missing
                    cell.value = f"SCHOOL : {school_name}"
                elif "CLASS :" in cell_value:
                    class_id = school.get('CLASS', '') # Use 'Unknown' or an appropriate default if the key is missing
                    cell.value = f"CLASS : {class_id}"

    # Filling in student IDs from DataFrame df
    student_ids = df[df['School Code'] == school['School Code']]['STUDENT ID'].tolist()

    # Find the "STUDENT ID" column
    student_id_column = None
    for row in ws.iter_rows():
        for cell in row:
            if cell.value and "STUDENT ID" in str(cell.value):
                student_id_column = cell.column
                start_row = cell.row + 1  # Start filling from the next row
                break
        if student_id_column:
            break

    # Fill the student IDs in the corresponding column
    if student_id_column:
        for idx, student_id in enumerate(student_ids):
            cell = ws.cell(row=start_row + idx, column=student_id_column, value=student_id)
            cell.font = Font(name='Calibri', size=11)

    # Remove rows after the last student ID entry
    last_row = start_row + len(student_ids)
    for row in ws.iter_rows(min_row=last_row, max_col=ws.max_column):
        for cell in row:
            cell.value = None

    # Apply borders only up to the last filled row
    if student_id_column:
        last_row = start_row + len(student_ids) - 1
        thin_border = Border(left=Side(border_style="thin"),
                             right=Side(border_style="thin"),
                             top=Side(border_style="thin"),
                             bottom=Side(border_style="thin"))

        # Remove border from rows below the last row with student IDs
        for row in ws.iter_rows(min_row=last_row + 1, max_row=ws.max_row):
            for cell in row:
                cell.border = Border()  # Clear borders

    # Center align all rows below the "STUDENT ID" row
    for row in ws.iter_rows(min_row=start_row, max_row=ws.max_row):
        for cell in row:
            cell.alignment = Alignment(horizontal='center', vertical='center')

    # Identify the row containing "S.NO" or "STUDENT ID"
    start_row = None
    for row in ws.iter_rows():
        for cell in row:
            if cell.value and ("S.NO" in str(cell.value) or "STUDENT ID" in str(cell.value)):
                start_row = cell.row
                break

    # If the start_row is found, set the row height from that row onwards
    if start_row:
        for row in ws.iter_rows(min_row=start_row, max_row=ws.max_row):
            ws.row_dimensions[row[0].row].height = 60


    # Adjust column widths to fit content
    dim_holder = DimensionHolder(worksheet=ws)
    for col in range(ws.min_column, ws.max_column + 1):
        dim = ColumnDimension(ws, min=col, max=col, width=18)  # Adjust width as needed
        dim_holder[get_column_letter(col)] = dim
    ws.column_dimensions = dim_holder

    # Set page margins to narrow
    ws.page_margins = PageMargins(left=0.25, right=0.25, top=0.25, bottom=0.25)

    # Set page size to A4
    ws.sheet_properties.pageSetUpPr.fitToPage = True
    ws.page_setup.paperSize = ws.PAPERSIZE_A4
    ws.page_setup.fitToWidth = 1
    ws.page_setup.fitToHeight = 0

    # Save each worksheet as a new Excel file named after the school code
    output_excel_filename = f'school_{school["School Code"]}.xlsx'
    wb.save(output_excel_filename)

    # Convert the Excel file to PDF
    output_pdf_filename = f'school_{school["School Code"]}.pdf'
    !libreoffice --headless --convert-to pdf --outdir /content {output_excel_filename}

    break

import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import Font
from openpyxl.styles.borders import Border, Side
from openpyxl.styles import Border, Side, Alignment
from openpyxl.worksheet.page import PageMargins
from openpyxl.worksheet.dimensions import ColumnDimension, DimensionHolder
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.page import PageMargins

df = pd.read_excel('/content/All Data.xlsx')

# Identify columns excluding 'Student ID' and those that are entirely empty
grouping_columns = [col for col in df.columns if col not in ['STUDENT ID'] and df[col].notna().any()]

# Group by the identified columns and count the number of unique 'Student ID'
grouped = df.groupby(grouping_columns).agg(student_count=('STUDENT ID', 'nunique')).reset_index()

# Process 'CLASS' column if it exists and contains non-numeric values
if 'CLASS' in grouped.columns and grouped['CLASS'].astype(str).str.contains('\D').any():
    grouped['CLASS'] = grouped['CLASS'].astype(str).str.extract('(\d+)')

# Count distinct schools
num_distinct_schools = grouped['School Code'].nunique()
print("Number of distinct schools:", num_distinct_schools)

# Convert the result to a list of dictionaries
result = grouped.to_dict(orient='records')
result